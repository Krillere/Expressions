# Recursive factorial. Highly inefficient. Should replace.
define factorial: Int num -> Int {
  if num <= 1 { 1 } { num * factorial(num-1) }
}

# Is the list empty?
define null: [Generic] lst -> Bool {
  length(lst) == 0
}

# First object in list
define first: [Generic] lst -> Generic {
  get(lst, 0)
}

# Last object in list
define last: [Generic] lst -> Generic {
  get(lst, length(lst)-1)
}

# Map function (Applies 'func' to each object in 'items')
define map: [Generic] items, (Generic -> Generic) func -> [Generic] {
  if null(items) { [] }
                 { append(list(func(first(items))), map(tail(items), func)) }
}
# Another map functions, this one takes two lists and applies a fucntion with two arguments to each element in each list
define map: [Generic] items1, [Generic] items2, (Generic, Generic -> Generic) func -> [Generic] {
  if (length(items1) != length(items2)) OR null(items1) OR null(items2) { [] }
  { append(list(func(first(items1), first(items2))), map(tail(items1), tail(items2), func))  }
}

# Filter function (Tests each object using 'func', if true, add to list)
define filter: [Generic] lst, (Generic -> Bool) func -> [Generic] {
  switch null(lst) { [] } # Stop if empty
         func(first(lst)) { append(list(first(lst)), filter(tail(lst), func)) }
         else { filter(tail(lst), func) }
}

# Is the number even?
define even: Int a -> Bool {
  (a % 2) == 0
}

# Is the number not even?
define odd: Int a -> Bool {
  !even(a)
}

# Subsets a list
define subset: [Generic] lst, Int from, Int to -> [Generic] {
    subsetHelper(lst, from, to, 0)
}
define subsetHelper: [Generic] lst, Int from, Int to, Int cur -> [Generic] {
    switch null(lst) { [] } # No more in lst
           cur < from { subsetHelper(tail(lst), from, to, cur+1) } # We haven't reached from yet
           cur == from { append(list(first(lst)), subsetHelper(tail(lst), from, to, cur+1)) } # Start subsetting
           cur < to AND cur > from { append(list(first(lst)), subsetHelper(tail(lst), from, to, cur+1)) }
           cur == to { list(first(lst)) }
           else { [] }
}

# Gets the first index of a value, or -1
define indexOf: [Generic] lst, Generic item -> Int {
  indexOfHelper(lst, item, 0)
}
define indexOfHelper: [Generic] lst, Generic item, Int curIndex -> Int {
  switch null(lst) { -1 }
         first(lst) == item { curIndex }
         else { indexOfHelper(tail(lst), item, curIndex+1) }
}

# Split list at specific object
define split: [Generic] lst, Generic spl -> [[Generic]] {
  if indexOf(lst, spl) == -1 { [[]] }
                             {  splitHelper(lst, spl) }
}

define splitHelper: [Generic] lst, Generic spl -> [[Generic]] {
  if null(lst) { [[]] } # Stop if lst is empty
  {
    let Int index = indexOf(lst, spl) # Does lst contain spl and where?
    {
      if index == -1 { list(lst) } # Stop if it does not
      {
        let [Generic] sub = subset(lst, 0, index-1) {
          append(list(sub), splitHelper(subset(lst, index+1, length(lst)), spl))
        }
      }
    }
  }
}

# Creates a list containing the first and last element of 'lst'
define ends: [Generic] lst -> [Generic] {
  let Generic f = first(lst), Generic l = last(lst) {
    append(list(f), l)
  }
}

# Does the list have a specific prefix?
define hasPrefix: [Generic] lst, [Generic] items -> Bool {
  if null(items) OR (length(items) > length(lst)) { false }
  {
    prefixHelper(lst, items)
  }
}
define prefixHelper: [Generic] lst, [Generic] items -> Bool {
  if null(items) { true }
  {
    let Generic fLst = first(lst), Generic fItems = first(items) {
      if fLst != fItems { false }
                        { prefixHelper(tail(lst), tail(items)) }
    }
  }
}

# Does the list have a specific postfix? (Uses prefix but reverses first)
define hasPostfix: [Generic] lst, [Generic] items -> Bool {
  hasPrefix(reverse(lst), reverse(items))
}
