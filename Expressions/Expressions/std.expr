define factorial: Int num -> Int {
  if num <= 1 { 1 } { num * factorial(num-1) }
}

# Map function (Applies 'func' to each object in 'items')
define map: [Generic] items, (Generic -> Generic) func -> [Generic] {
  if null(items) { [] }
                 { append(list(func(first(items))), map(tail(items), func)) }
}
define map: [Generic] items1, [Generic] items2, (Generic, Generic -> Generic) func -> [Generic] {
  if (length(items1) != length(items2)) OR null(items1) OR null(items2) { [] }
  { append(list(func(first(items1), first(items2))), map(tail(items1), tail(items2), func))  }
}

# Filter function (Tests each object using 'func', if true, add to list)
define filter: [Generic] lst, (Generic -> Bool) func -> [Generic] {
  switch null(lst) { [] } # Stop if empty
         func(first(lst)) { append(list(first(lst)), filter(tail(lst), func)) }
         else { filter(tail(lst), func) }
}

define even: Int a -> Bool {
  (a % 2) == 0
}

define odd: Int a -> Bool {
  !even(a)
}
define addNumbers: Int a, Int b -> Int {
  a + b
}

# Subsets a list
define subset: [Generic] lst, Int from, Int to -> [Generic] {
    subsetHelper(lst, from, to, 0)
}
define subsetHelper: [Generic] lst, Int from, Int to, Int cur -> [Generic] {
    switch null(lst) { [] } # No more in lst
           cur < from { subsetHelper(tail(lst), from, to, cur+1) } # We haven't reached from yet
           cur == from { append(list(first(lst)), subsetHelper(tail(lst), from, to, cur+1)) } # Start subsetting
           cur < to AND cur > from { append(list(first(lst)), subsetHelper(tail(lst), from, to, cur+1)) }
           cur == to { list(first(lst)) }
           else { [] }
}

# Gets the first index of a value, or -1
define indexOf: [Generic] lst, Generic item -> Int {
  indexOfHelper(lst, item, 0)
}
define indexOfHelper: [Generic] lst, Generic item, Int curIndex -> Int {
  switch null(lst) { -1 }
         first(lst) == item { curIndex }
         else { indexOfHelper(tail(lst), item, curIndex+1) }
}
